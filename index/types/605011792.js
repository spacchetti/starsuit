// This file was generated by purescript-docs-search
window.DocsSearchTypeIndex["605011792"] = [{"values":[{"sourceSpan":{"start":[129,1],"name":".spago/halogen-hooks-extra/v0.3.0/src/Halogen/Hooks/Extra/Hooks/UseEvent.purs","end":[132,81]},"score":0,"packageName":"halogen-hooks-extra","name":"useEvent","moduleName":"Halogen.Hooks.Extra.Hooks.UseEvent","info":{"values":[{"type":{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["slots",{"tag":"ForAll","contents":["m",{"tag":"ForAll","contents":["output",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Effect","Class"],"MonadEffect"],"constraintArgs":[{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","UseHookF"],"Hook"]},{"tag":"TypeVar","contents":"slots"}]},{"tag":"TypeVar","contents":"output"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","Extra","Hooks","UseEvent"],"UseEvent"]},{"tag":"TypeVar","contents":"slots"}]},{"tag":"TypeVar","contents":"output"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}}]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","Extra","Hooks","UseEvent"],"EventApi"]},{"tag":"TypeVar","contents":"slots"}]},{"tag":"TypeVar","contents":"output"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}}]}]},null]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Allows you to \"push\" events that occur inside a hook\nto a single handler outside of the hook. This allows the end user\nto use the full API returned by the hook when handling the event.\n\nThere are two ways this can be used, depending on what the value of\nthe type, `a`, is. The first is more flexible but uses multiple\n`useRef` hooks internally whereas the second is less flexible but\nmore performant because only one `useRef` hook is used internally.\n\nNote: the event handler is a callback that is stored in a `Ref`. Thus, you\ncan \"unsubscribe\" from the events by setting the `Ref`'s value to `Nothing`\nor you can \"unsubscribe\" and \"resubscribe\" in the same action by setting\nthe `Ref`'s value to `Just newCallback`.\n\n\n## Conditionally Subscribe and Unsubscribe (Less Performant)\n\nIn these kinds of situations, one would `useEvent` one time for each event.\nOne should use this approach when one needs to conditionally subscribe\nand unsubscribe to a hook's internal events. For example, when X is true,\nthen subscribe to the event that notifies us that some aspect of our code\nis now visible. When X is false, don't get notified of those things\nanymore.\nOr, perhaps you wish to change how you handle those events. When X is true,\ndo Y. When X is false, do Z. Use this hook according to the below example\nin such circumstances:\n\n```\n-- in the custom Hook code...\nonEvent1 <- useEvent\nonEvent2 <- useEvent\n\n-- somewhere in your HookM code\n  onEvent1.push \"user clicked foo\"\n\n-- somewhere else in your HookM code\n  onEvent2.push \"user clicked foo\"\n\nHooks.pure\n  { onEvent1: onEvent1.setCallback\n  , onEvent2: onEvent2.setCallback\n  }\n\n--------------\n-- in end user Hook code\n\nstate /\\ tState <- useState 0\nsomeLib <- useSomeLibHook\n\nHooks.captures { state } Hooks.useTickEffect do\n  someLib.onEvent1 \\string -> do\n    Hooks.raise (\"Event occurred: \" <> string)\nHooks.captures { state, state2 } Hooks.useTickEffect do\n  state1' <- Hooks.get tState1\n  state2' <- Hooks.get tState2\n  when (state1 /= state2) do\n    someLib.onEvent2 \\string -> do -- something\n```\n\n## Subscribe on Initialization and Never Unsubscribe (More Performant)\n\nIn this situation, one would `useEvent` one time for the entire\ncomponent to which multiple hooks can push their specific events.\nOne should use this when they will always subscribe to these events\nusing the same event handlers. In other words, they won't need to\nunsubscribe and resubscribe later on.\nUse this hook according to the below example in such circumstances:\n```\n-- in the custom Hook code...\nuseFoo pushEvent = Hooks.do\n\n -- somewhere in your HookM code\n  pushEvent \"user clicked foo\"\n\nHooks.pure customHookReturnValue\n\n--------------\n-- in end user Hook code\n\neventBus <- useEvent\n\nlet\n  _libName = SProxy :: SProxy \"libName\"\n  pushLibEvent = \\value -> eventBus.push $ Variant.inj _libName value\n\nsomeLib <- useSomeLibHook pushLibEvent\nuseLifecycleEffect do\n  eventBus.setCallback $\n    Variant.case_\n      # _libName \\string -> do\n           Hooks.raise (\"Event occurred: \" <> string)\n      # _otherLibName \\x -> do\n          Hooks.put tMyState x\n```\n"}],"tag":"SearchResult"}]