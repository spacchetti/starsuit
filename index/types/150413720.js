// This file was generated by purescript-docs-search
window.DocsSearchTypeIndex["150413720"] = [{"values":[{"sourceSpan":{"start":[304,1],"name":".spago/parsing/v5.1.0/src/Text/Parsing/Parser/Token.purs","end":[304,92]},"score":11,"packageInfo":{"values":["parsing"],"tag":"Package"},"name":"makeTokenParser","moduleName":"Text.Parsing.Parser.Token","info":{"values":[{"type":{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Control","Monad"],"Monad"],"constraintArgs":[{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Text","Parsing","Parser","Token"],"GenLanguageDef"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"tag":"TypeVar","contents":"m"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Text","Parsing","Parser","Token"],"GenTokenParser"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"tag":"TypeVar","contents":"m"}]}]}]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"The expression `makeTokenParser language` creates a `GenTokenParser`\nrecord that contains lexical parsers that are\ndefined using the definitions in the `language` record.\n\nThe use of this function is quite stylized - one imports the\nappropiate language definition and selects the lexical parsers that\nare needed from the resulting `GenTokenParser`.\n\n```purescript\nmodule Main where\n\nimport Text.Parsing.Parser.Language (haskellDef)\nimport Text.Parsing.Parser.Token (makeTokenParser)\n\n-- The parser\nexpr = parens expr\n   <|> identifier\n   <|> ...\n\n\n-- The lexer\ntokenParser = makeTokenParser haskellDef\nparens      = tokenParser.parens\nbraces      = tokenParser.braces\nidentifier  = tokenParser.identifier\nreserved    = tokenParser.reserved\n...\n```\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":{"start":[149,1],"name":".spago/pathy/v7.0.1/src/Pathy/Path.purs","end":[149,63]},"score":0,"packageInfo":{"values":["pathy"],"tag":"Package"},"name":"parentOf","moduleName":"Pathy.Path","info":{"values":[{"type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Pathy","Phantom"],"IsRelOrAbs"],"constraintArgs":[{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Pathy","Path"],"Path"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Pathy","Phantom"],"Dir"]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Pathy","Path"],"Path"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Pathy","Phantom"],"Dir"]}]}]}]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Creates a path that points to the parent directory of the specified path.\n\nCalling `parentOf` on `rootDir` will return `rootDir`.\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":{"start":[249,1],"name":".spago/halogen-hooks/v0.4.3/src/Halogen/Hooks/HookM.purs","end":[249,51]},"score":1,"packageInfo":{"values":["halogen-hooks"],"tag":"Package"},"name":"fork","moduleName":"Halogen.Hooks.HookM","info":{"values":[{"type":{"tag":"ForAll","contents":["m",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","HookM"],"HookM"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","HookM"],"HookM"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeConstructor","contents":[["Halogen","Query","HalogenM"],"ForkId"]}]}]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Starts a `HalogenM` process running independent from the current `eval`\n\"thread\".\n\nA commonly use case for `fork` is in component initializers where some\nasync action is started. Normally all interaction with the component will\nbe blocked until the initializer completes, but if the async action is\n`fork`ed instead, the initializer can complete synchronously while the\nasync action continues.\n\nSome care needs to be taken when using a `fork` that can modify the\ncomponent state, as it's easy for the forked process to \"clobber\" the state\n(overwrite some or all of it with an old value) by mistake.\n\nWhen a component is disposed of any active forks will automatically\nbe killed. New forks can be started during finalization but there will be\nno means of killing them.\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":{"start":[208,1],"name":".spago/arraybuffer-builder/v1.1.0/src/Data/ArrayBuffer/Builder.purs","end":[208,73]},"score":1,"packageInfo":{"values":["arraybuffer-builder"],"tag":"Package"},"name":"subBuilder","moduleName":"Data.ArrayBuffer.Builder","info":{"values":[{"type":{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Effect","Class"],"MonadEffect"],"constraintArgs":[{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","ArrayBuffer","Builder"],"PutM"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","ArrayBuffer","Builder"],"PutM"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeConstructor","contents":[["Data","ArrayBuffer","Builder"],"Builder"]}]}]}]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Build up a sub-`Builder` without `tell`ing it to the `Writer` yet.\n\nOne case where we might want to call a `subBuilder` is when\nserializing length-prefixed messages in some protocol. In that case,\nwe must serialize the message first, calculate the message length,\nappend the message length, and then append the message.\n\nIn a `PutM` monad do-block, we can\n\n\n```\ndo\n  messageBuilder <- subBuilder $ do\n    putField1\n    putField2\n\n  putInt32 $ length messageBuilder\n  tell messageBuilder\n```\n"}],"tag":"SearchResult"}]