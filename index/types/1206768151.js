// This file was generated by purescript-docs-search
window.DocsSearchTypeIndex["1206768151"] = [{"values":[{"sourceSpan":{"start":[79,1],"name":".spago/halogen-hooks-extra/v0.7.1/src/Halogen/Hooks/Extra/Hooks/UseGet.purs","end":[83,35]},"score":0,"packageInfo":{"values":["halogen-hooks-extra"],"tag":"Package"},"name":"useGet","moduleName":"Halogen.Hooks.Extra.Hooks.UseGet","info":{"values":[{"type":{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Effect","Class"],"MonadEffect"],"constraintArgs":[{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","Hook"],"Hook"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","Extra","Hooks","UseGet"],"UseGet"]},{"tag":"TypeVar","contents":"a"}]}}]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","HookM"],"HookM"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}}]}]}]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Use this hook when you wish to ensure that your reference to a state\nvalue or the component's input is not \"stale\" or outdated. Usually, this\nhappens in when you define a computation in one \"Hook evaluation cycle,\"\nbut you do not run the computation until a future \"Hook evaluation cycle.\"\nThis typically occurs when running a `useLifecycleEffect`/`useTickEffect`'s\ncleanup/finalizer/unsubscribe computation.\n\nLet's see an example of an effect's finalizer referring to a stale value\nin code. If you don't use `useGet` in this situation, you will refer to\nwhat the value used to be (a stale value), not what the value is now:\n```\nmyComponent :: forall q i o m. MonadAff m => H.Component HH.HTML q i o m\nmyComponent = Hooks.component \\_ _ -> Hooks.do\n  thisIsFive_NotSix /\\ stateId <- Hooks.useState 5\n  let modifyState = Hooks.modify_ stateId\n\n  Hooks.captures {} Hooks.useTickEffect do\n    -- The `thisIsFive_NotSix` state reference is currently `5` and\n    -- is up-to-date because this effect body runs immediately\n    -- after the Hook evaluation in which it is defined.\n    -- Thus, this will print \"5\" to the console.\n    logShow thisIsFive_NotSix\n\n    -- Now we change the value to 6\n    modifyState (_ + 1)\n\n    pure $ Just $ do\n      -- The effect cleanup, however, will not run after the Hook\n      -- evaluation in which it is defined. Thus, the `thisIsFive_NotSix`\n      -- state reference is still `5` even though we previously\n      -- updated the real value to 6.\n      -- Thus, this will print \"5\" to the console when it should print \"6\".\n      logShow thisIsFive_NotSix\n```\nTo ensure we refer to the latest value and not a stale one, we use\nthis hook to do so.\n```\nmyComponent :: forall q i o m. MonadAff m => H.Component HH.HTML q i o m\nmyComponent = Hooks.component \\_ _ -> Hooks.do\n  thisIsFive_NotSix /\\ stateId <- Hooks.useState 5\n  let modifyState = Hooks.modify_ stateId\n\n  -- This returns a function to get the latest state/input value.\n  getState <- useGet thisIsFive_NotSix\n\n  Hooks.captures {} Hooks.useTickEffect do\n    logShow thisIsFive_NotSix\n\n    modifyState (_ + 1)\n\n    pure $ Just $ do\n      -- Now we get the latest value rather than using the stale value.\n      -- This correctly prints \"6\".\n      thisIsSix_NotFive <- getState\n      logShow thisIsSix_NotFive\n```\n"}],"tag":"SearchResult"}]