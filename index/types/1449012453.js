// This file was generated by purescript-docs-search
window.DocsSearchTypeIndex["1449012453"] = [{"values":[{"sourceSpan":{"start":[99,1],"name":".spago/halogen-hooks-extra/v0.4.0/src/Halogen/Hooks/Extra/Hooks/UseEvent.purs","end":[102,21]},"score":0,"packageName":"halogen-hooks-extra","name":"useEvent","moduleName":"Halogen.Hooks.Extra.Hooks.UseEvent","info":{"values":[{"type":{"tag":"ForAll","contents":["hooks",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Effect","Class"],"MonadEffect"],"constraintArgs":[{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","Hook"],"Hooked"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"hooks"}]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","Extra","Hooks","UseEvent"],"UseEvent"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"hooks"}]}}]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","Extra","Hooks","UseEvent"],"EventApi"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}}]}]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Allows you to \"push\" events that occur inside a hook\nto a single handler outside of the hook. This allows the end user\nto use the full API returned by the hook when handling the event.\nMoreover, the end-user can set up resources on the first time\nthe handler is run and unsubscribe when the finalizer is run.\n\nFor example...\n```\n-- let's say this is the end-user's Hook code\nonEvent <- useEvent\n\n-- Here, we'll inline the code for a hypothetical hook we found. This could\n-- be a hook provided by a library or something.\n{ foo } <- Hooks.do\n\n  -- somewhere in the hypothetical hook, an event occurs\n  onEvent.push \"user clicked foo\"\n\n  pure { foo: \"foo\" } -- return value of the hook provided by the library\n\nHooks.useLifecycleEffect do\n  unsubscribe <- onEvent.setCallback $ Just \\setupSubscription str -> do\n    -- handle the event\n    Hooks.raise (\"Event occurred: \" <> str)\n\n    setupSubscription do\n      -- Then, set up some resources in this code block\n      -- that need to be cleaned up later\n      liftEffect $ log $ \"Setting up resources.\"\n\n      pure do\n        -- now define the code that will run when we call\n        -- 'unsubscribe' later\n        liftEffect $ log $ \"Cleaning up resources.\"\n\n  pure $ Just do\n    -- unsubscribe to clean up resources\n    unsubscribe\n\nstate /\\ tState <- useState 0\n\n-- If we don't need to unsubscribe, just ignore the argument\nHooks.captures { state } Hooks.useTickEffect do\n  -- notice two things here. First, we're ignoring the\n  -- 'unsubscribeCallback' argument by using the underscore (i.e. _)\n  -- Second, we're ignoring the returned 'unsubscribe' code by using\n  -- `void`.\n  void $ onEvent \\_ string -> do\n    -- handle the event\n    Hooks.raise (\"Event occurred: \" <> string)\n\n  pure Nothing -- no need to unsubscribe here\n```\n"}],"tag":"SearchResult"}]