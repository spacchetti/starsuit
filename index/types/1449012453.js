// This file was generated by purescript-docs-search
window.DocsSearchTypeIndex["1449012453"] = [{"values":[{"sourceSpan":{"start":[132,1],"name":".spago/halogen-hooks-extra/v0.6.0/src/Halogen/Hooks/Extra/Hooks/UseEvent.purs","end":[135,24]},"score":0,"packageName":"halogen-hooks-extra","name":"useEvent","moduleName":"Halogen.Hooks.Extra.Hooks.UseEvent","info":{"values":[{"type":{"tag":"ForAll","contents":["hooks",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Effect","Class"],"MonadEffect"],"constraintArgs":[{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","Hook"],"Hooked"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"hooks"}]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","Extra","Hooks","UseEvent"],"UseEvent"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"hooks"}]}}]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Hooks","Extra","Hooks","UseEvent"],"UseEventApi"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}}]}]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Allows you to \"push\" events that occur inside a hook\nto a single handler outside of the hook. This allows the end user\nto use the full API returned by the hook when handling the event.\nMoreover, the end-user can set up resources on the first time\nthe handler is run and unsubscribe when the finalizer is run.\n\nFor example...\n```\n-- let's say this is the end-user's Hook code\nonEvent <- useEvent\n\n-- Here, we'll inline the code for a hypothetical hook we found.\n-- This could be a hook provided by a library or something.\n{ foo } <- Hooks.do\n\n  -- somewhere in the hypothetical hook, an event occurs\n  onEvent.push \"user clicked foo\"\n\n  -- return the value of the hook provided by the library\n  pure { foo: \"foo\" }\n\nHooks.useLifecycleEffect do\n  unsubscribe <- onEvent.setCallback $ Just \\setupSubscription str -> do\n    -- handle the event\n    Hooks.raise (\"Event occurred: \" <> str)\n\n    setupSubscription do\n      -- Then, set up some resources in this code block\n      -- that need to be cleaned up later\n      liftEffect $ log $ \"Setting up resources.\"\n\n      pure do\n        -- now define the code that will run when we call\n        -- 'unsubscribe' later\n        liftEffect $ log $ \"Cleaning up resources.\"\n\n  pure $ Just do\n    -- unsubscribe to clean up resources\n    unsubscribe\n```\nIf you don't need to unsubscribe, just ignore the first argument\nin the function passed to `onEvent`:\n```\nstate /\\ tState <- useState 0\n\nHooks.captures { state } Hooks.useTickEffect do\n  -- Notice two things here:\n  -- 1. we're ignoring the 'unsubscribeCallback' argument\n  --        by using the underscore (i.e. _).\n  -- 2. we're ignoring the returned 'unsubscribe' code by using `void`.\n  void $ onEvent \\_ string -> do\n    -- handle the event\n    Hooks.raise (\"Event occurred: \" <> string)\n\n  pure Nothing -- no need to unsubscribe here\n```\n\n## Beware Infinite Loops\n\nIf you use this hook, it's possible for you to create an infinite loop.\nThis will occur if a handler runs code that causes another event to\nbe emitted. Consider this workflow:\n\n1. Event A is emitted\n2. During A's handler, Action X is called\n3. During Action X's computation, Event A is emitted.\n4. An infinite loop occurs (go to Step 2)\n\nHere's an example in code:\n```\nlibrary <- useLibrary\nuseLifecycleEffect do\n  library.onNewInteger \\newInt -> do\n    library.setIntValue (newInt + 1)\n```\nConsider also cases where the chain is longer and\nsome computations run only when certain conditions are true:\n\n1. Event A is emitted\n2. During A's handler, Action X is called\n3. During Action X's computation, Event B is emitted.\n4. During B's handler, Action Y is called\n5. During Action Y's computation, Event C is emitted but only if State M is equal to 4.\n6. During C's handler, Action Z is called\n7. During Action Z's computation, Event A is emitted.\n8. Infinite loop may occur (depends on State M)\n"}],"tag":"SearchResult"}]